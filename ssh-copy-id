#!/bin/sh

# Copyright (c) 1999-2010 Philip Hands <phil@hands.com>
#               2010 Adeodato =?iso-8859-1?Q?Sim=F3?= <asp16@alu.ua.es>
#               2010 Eric Moret <eric.moret@gmail.com>
#               2009 Xr <xr@i-jeuxvideo.com>
#               2007 Justin Pryzby <justinpryzby@users.sourceforge.net>
#               2004 Reini Urban <rurban@x-ray.at>
#               2003 Colin Watson <cjwatson@debian.org>
# Modification and redistribution is permitted provided that due credit
# is given to the authors by leaving this copyright notice intact.

# Shell script to install your public key(s) on a remote machine
# See the ssh-copy-id(1) man page for details

DEFAULT_PUB_ID_FILE=$(ls -t ${HOME}/.ssh/id*.pub | head -n 1)

usage () {
  echo "Usage: $0 [-h|-?|-n] [-i [identity_file]] [-p port] [user@]hostname" >&2
  exit 1
}

use_id_file() {
  local L_ID_FILE=$1

  if expr "$L_ID_FILE" : ".*\.pub$" >/dev/null ; then
    PUB_ID_FILE="$L_ID_FILE"
  else
    PUB_ID_FILE="$L_ID_FILE.pub"
  fi

  PRIV_ID_FILE=$(dirname "$PUB_ID_FILE")/$(basename "$PUB_ID_FILE" .pub)

  # check that the files are readable
  for f in $PUB_ID_FILE $PRIV_ID_FILE ; do
    ErrMSG=$( { : < $f ; } 2>&1 ) || {
      printf "\n%s: ERROR: failed to open ID file '%s': %s\n\n" "$0" "$f" "$(echo $ErrMSG | sed -e 's/.*: *//')"
      exit 1
    }
  done
  GET_ID="cat \"$PUB_ID_FILE\""
}

if [ -n "$SSH_AUTH_SOCK" ] && ssh-add -L >/dev/null 2>&1 ; then
  GET_ID="ssh-add -L"
fi

GETOPT_PARSED=$(getopt --options 'i::p:nh?' --name "$0" --quiet -- "$@")

eval set -- "$GETOPT_PARSED"
while true ; do
  case "$1" in
    -i)
      case "$2" in
        '')
          CHECK_EXTRA_PARAM=1
          use_id_file $DEFAULT_PUB_ID_FILE
          ;;
        *)
          use_id_file $2
          ;;
      esac
      shift 2
      ;;
    -p)
      if 2>/dev/null [ "$2" -gt 0 ] && [ "$2" -lt 65536 ] ; then
        PORTOPTION="-p $2 "
      else
        echo "Bad port '$2'" >&2
        exit 1
      fi
      shift 2
      ;;
    -n)
      DRY_RUN=1
      shift
      ;;
    -h|-\?)
      usage
      shift
      ;;
    --)
      shift
      break
      ;;
  esac
done

if [ -n "$CHECK_EXTRA_PARAM" ] && [ $# == 2 ] ; then
  use_id_file $1
  shift
fi

if [ $# != 1 ] ; then
  usage
fi

# drop a trailing colon
USER_HOST=${1%:}

if [ -z "$(eval $GET_ID)" ] && [ -r "$PUB_ID_FILE" ] ; then
  use_id_file $PUB_ID_FILE
fi

if [ -z "$(eval $GET_ID)" ] ; then
  echo "$0: ERROR: No identities found" >&2
  exit 1
fi

populate_new_ids() {
  local L_USER_HOST="$1"
  local L_SUCCESS="$2"

  ID_FILE_TEMP=$(mktemp ~/.ssh/ssh-copy-id_id.XXXXXXXXXX)
  trap "rm -f $ID_FILE_TEMP" EXIT TERM INT QUIT
  NEW_IDS=$(
    eval $GET_ID | {
      while read ID ; do
        printf "$ID\n" > $ID_FILE_TEMP

        # the next line assumes $PRIV_ID_FILE only set if using a single id file - this
        # assumption will break if we implement the possibility of multiple -i options.
        # The point being that if file based, ssh needs the private key, which it cannot
        # find if only given the contents of the .pub file in an unreleated tmpfile
        RESULT=$(
          { {
            ssh -i "${PRIV_ID_FILE:-$ID_FILE_TEMP}" \
                -o PreferredAuthentications=publickey \
                -o IdentitiesOnly=yes $PORTOPTION $L_USER_HOST exit 2>&1
            [ "$?" = "$L_SUCCESS" ] && printf OK >&2
          } | {
            grep -q 'Could not resolve hostname' && printf ENORESOLVE
          } ; } 2>&1 # catch "OK"
        )

        case "$RESULT" in
          OK)
            : output nothing, as that key worked
            ;;
          ENORESOLVE)
            printf "ENORESOLVE\n"
            ;;
          *)
            printf "$ID\n"
            ;;
        esac
      done
    }
  )
  rm -f "$ID_FILE_TEMP" && trap - EXIT TERM INT QUIT

  if expr "$NEW_IDS" : "^ENORESOLVE" >/dev/null ; then
    printf "\n$0: ERROR: Could not resolve hostname.\n\n" >&2
    exit 1
  fi
  if [ -z "$NEW_IDS" ] ; then
    printf "\n$0: WARNING: All keys were skipped because they already exist on the remote system.\n\n" >&2
    exit 0
  fi
}

REMOTE_VERSION=$(ssh -v -o PreferredAuthentications=',' $PORTOPTION $USER_HOST 2>&1 |
                 sed -ne 's/.*remote software version //p')

case "$REMOTE_VERSION" in
  NetScreen*)
    populate_new_ids $USER_HOST 1
    for KEY in $(echo "$NEW_IDS"| cut -d' ' -f2) ; do
      [ "$DRY_RUN" ] || printf 'set ssh pka-dsa key %s\nsave\nexit\n' "$KEY" | ssh -T $PORTOPTION $USER_HOST >/dev/null 2>&1
      if [ $? == 255 ] ; then
        echo "$0: WARNING: NetScreen only supports dsa keys" >&2
      else
        ADDED=$(($ADDED + 1))
      fi
    done
    if [ -z "$ADDED" ] ; then
      exit 1
    fi
    ;;
  *)
    # Assuming default being OpenSSH
    populate_new_ids $USER_HOST 0
    [ "$DRY_RUN" ] || printf "\n$NEW_IDS\n" | ssh $PORTOPTION $USER_HOST "umask 077 ; mkdir -p .ssh ; cat >> .ssh/authorized_keys" || exit 1
    ADDED=$( { printf "$NEW_IDS" ; echo ; } | wc -l)
    ;;
esac

if [ "$DRY_RUN" ] ; then
    echo "Would have added the following keys:"
    printf "\n$NEW_IDS\n"
fi

cat <<-EOF

	Number of key(s) added: $ADDED

	Now try logging into the machine, with "ssh $PORTOPTION'$USER_HOST'", and check
	to make sure we haven't added extra keys that you weren't expecting.

EOF
