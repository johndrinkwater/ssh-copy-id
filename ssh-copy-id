#!/bin/sh

# Copyright (c) 1999-2013 Philip Hands <phil@hands.com>
#               2013 Martin Kletzander <mkletzan@redhat.com>
#               2010 Adeodato =?iso-8859-1?Q?Sim=F3?= <asp16@alu.ua.es>
#               2010 Eric Moret <eric.moret@gmail.com>
#               2009 Xr <xr@i-jeuxvideo.com>
#               2007 Justin Pryzby <justinpryzby@users.sourceforge.net>
#               2004 Reini Urban <rurban@x-ray.at>
#               2003 Colin Watson <cjwatson@debian.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Shell script to install your public key(s) on a remote machine
# See the ssh-copy-id(1) man page for details

DEFAULT_PUB_ID_FILE=$(ls -t ${HOME}/.ssh/id*.pub | grep -v -- '-cert.pub$' | head -n 1)

usage () {
  echo "Usage: $0 [-h|-?|-n] [-i [identity_file]] [-p port] [user@]hostname" >&2
  exit 1
}

use_id_file() {
  local L_ID_FILE="$1"

  if expr "$L_ID_FILE" : ".*\.pub$" >/dev/null ; then
    PUB_ID_FILE="$L_ID_FILE"
  else
    PUB_ID_FILE="$L_ID_FILE.pub"
  fi

  PRIV_ID_FILE=$(dirname "$PUB_ID_FILE")/$(basename "$PUB_ID_FILE" .pub)

  # check that the files are readable
  for f in $PUB_ID_FILE $PRIV_ID_FILE ; do
    ErrMSG=$( { : < $f ; } 2>&1 ) || {
      printf "\n%s: ERROR: failed to open ID file '%s': %s\n\n" "$0" "$f" "$(echo $ErrMSG | sed -e 's/.*: *//')"
      exit 1
    }
  done
  GET_ID="cat \"$PUB_ID_FILE\""
}

if [ -n "$SSH_AUTH_SOCK" ] && ssh-add -L >/dev/null 2>&1 ; then
  GET_ID="ssh-add -L"
fi

GETOPT_PARSED=$(getopt --options 'i::p:nh?' --name "$0" --quiet -- "$@")

eval set -- "$GETOPT_PARSED"
while true ; do
  case "$1" in
    -i)
      case "$2" in
        '')
          CHECK_EXTRA_PARAM=1
          use_id_file "$DEFAULT_PUB_ID_FILE"
          ;;
        *)
          use_id_file "$2"
          ;;
      esac
      shift 2
      ;;
    -p)
      if 2>/dev/null [ "$2" -gt 0 ] && [ "$2" -lt 65536 ] ; then
        PORTOPTION="-p $2 "
      else
        echo "Bad port '$2'" >&2
        exit 1
      fi
      shift 2
      ;;
    -n)
      DRY_RUN=1
      shift
      ;;
    -h|-\?)
      usage
      shift
      ;;
    --)
      shift
      break
      ;;
  esac
done

if [ -n "$CHECK_EXTRA_PARAM" ] && [ $# = 2 ] ; then
  use_id_file "$1"
  shift
fi

if [ $# != 1 ] ; then
  usage
fi

# drop a trailing colon
USER_HOST=$(echo $1 | sed 's/:$//')

if [ -z "$(eval $GET_ID)" ] && [ -r "$PUB_ID_FILE" ] ; then
  use_id_file "$PUB_ID_FILE"
fi

if [ -z "$(eval $GET_ID)" ] ; then
  echo "$0: ERROR: No identities found" >&2
  exit 1
fi

# populate_new_ids() uses several global variables ($USER_HOST, $PORTOPTION ...)
# and has the side effect of setting $NEW_IDS
populate_new_ids() {
  local L_SUCCESS="$1"

  local L_TMP_ID_FILE=$(mktemp ~/.ssh/ssh-copy-id_id.XXXXXXXXXX)
  trap "rm -f $L_TMP_ID_FILE*" EXIT TERM INT QUIT
  printf "$0: INFO: attempting to log in with the new key(s), to filter out any that are already installed\n" >&2
  NEW_IDS=$(
    eval $GET_ID | {
      while read ID ; do
        printf "$ID\n" > $L_TMP_ID_FILE

        # the next line assumes $PRIV_ID_FILE only set if using a single id file - this
        # assumption will break if we implement the possibility of multiple -i options.
        # The point being that if file based, ssh needs the private key, which it cannot
        # find if only given the contents of the .pub file in an unrelated tmpfile
        ssh -i "${PRIV_ID_FILE:-$L_TMP_ID_FILE}" \
            -o PreferredAuthentications=publickey \
            -o IdentitiesOnly=yes $PORTOPTION $USER_HOST exit 2>$L_TMP_ID_FILE.stderr </dev/null
        if [ "$?" = "$L_SUCCESS" ] ; then
          : > $L_TMP_ID_FILE
        else
          if ! grep -q 'Permission denied' $L_TMP_ID_FILE.stderr ; then
            sed -e 's/^/ERROR: /' <$L_TMP_ID_FILE.stderr >$L_TMP_ID_FILE
            cat >/dev/null #consume the other keys, causing loop to end
          fi
        fi

        cat $L_TMP_ID_FILE
      done
    }
  )
  rm -f $L_TMP_ID_FILE* && trap - EXIT TERM INT QUIT

  if expr "$NEW_IDS" : "^ERROR: " >/dev/null ; then
    printf "\n$0: $NEW_IDS\n\n" >&2
    exit 1
  fi
  if [ -z "$NEW_IDS" ] ; then
    printf "\n$0: WARNING: All keys were skipped because they already exist on the remote system.\n\n" >&2
    exit 0
  fi
}

REMOTE_VERSION=$(ssh -v -o PreferredAuthentications=',' $PORTOPTION $USER_HOST 2>&1 |
                 sed -ne 's/.*remote software version //p')

case "$REMOTE_VERSION" in
  NetScreen*)
    populate_new_ids 1
    for KEY in $(echo "$NEW_IDS"| cut -d' ' -f2) ; do
      KEY_NO=$(($KEY_NO + 1))
      echo "$KEY" | grep -q ssh-dss || {
         echo "$0: WARNING: Non-dsa key (#$KEY_NO) skipped (NetScreen only supports DSA keys)" >&2
         continue
      }
      [ "$DRY_RUN" ] || printf 'set ssh pka-dsa key %s\nsave\nexit\n' "$KEY" | ssh -T $PORTOPTION $USER_HOST >/dev/null 2>&1
      if [ $? = 255 ] ; then
        echo "$0: ERROR: installation of key #$KEY_NO failed (please report a bug describing what caused this, so that we can make this message useful)" >&2
      else
        ADDED=$(($ADDED + 1))
      fi
    done
    if [ -z "$ADDED" ] ; then
      exit 1
    fi
    ;;
  *)
    # Assuming that the remote host treats ~/.ssh/authorized_keys as one might expect
    populate_new_ids 0
    [ "$DRY_RUN" ] || printf "\n$NEW_IDS\n" | ssh $PORTOPTION $USER_HOST "
		umask 077 ;
		mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys || exit 1 ;
		! type restorecon >/dev/null 2>&1 || restorecon -F .ssh .ssh/authorized_keys" \
      || exit 1
    ADDED=$(printf "$NEW_IDS\n" | wc -l)
    ;;
esac

if [ "$DRY_RUN" ] ; then
  echo =-=-=-=-=-=-=-=
  echo "Would have added the following key(s):"
  printf "\n$NEW_IDS\n"
  echo =-=-=-=-=-=-=-=
fi

cat <<-EOF

	Number of key(s) added: $ADDED

	Now try logging into the machine, with "ssh $PORTOPTION'$USER_HOST'", and check
	to make sure we haven't added extra keys that you weren't expecting.

EOF
